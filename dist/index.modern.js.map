{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import difference from \"lodash.difference\";\nimport intersection from \"lodash.intersection\";\nimport isObj from \"lodash.isplainobject\";\nimport mergeWith from \"lodash.mergewith\";\n\n/****************************************************\n Constants\n****************************************************/\nconst ignore = Symbol(); // allows undefined query values to be used\nconst indexMap = new WeakMap();\n\n/****************************************************\n Main\n****************************************************/\nfunction EntityQuery<T extends { [key: string]: R }, R extends Obj>(\n  entities: T // normalized entities\n) {\n  return {\n    filter(query?: Query, options?: QueryOptions): R[] {\n      return search(entities, query, makeOptions(options)).map(\n        (id) => entities[id]\n      );\n    },\n\n    search(query?: Query, options?: QueryOptions): string[] {\n      return search(entities, query, makeOptions(options));\n    },\n  };\n}\n\nexport default EntityQuery;\n\nfunction search<T extends { [key: string]: R }, R extends Obj>(\n  entities: T,\n  query: Query | Query[] | typeof ignore = ignore,\n  opts: QueryOpts\n): string[] {\n  if (query === ignore) return Object.keys(entities);\n\n  const index =\n    (indexMap.get(entities) as Index) ||\n    (indexMap.set(entities, makeIndex(entities)).get(entities) as Index);\n\n  const idSets = (Array.isArray(query) ? query : [query]).map((query) =>\n    queryIndex(index, query)\n  );\n\n  switch (opts.conditions) {\n    case \"all\":\n      return intersection(...idSets);\n\n    case \"any\":\n      return [...new Set(...idSets)];\n\n    case \"diff\":\n      return idSets.length >= 2\n        ? difference(idSets[0], ...idSets.slice(1))\n        : [];\n\n    case \"none\":\n      return difference(Object.keys(entities), ...idSets);\n\n    default:\n      return intersection(...idSets);\n  }\n}\n\n/****************************************************\n Index Builder\n****************************************************/\nfunction makeIndex<T extends { [key: string]: R }, R extends Obj>(\n  root: T\n): Index {\n  return Object.values(root)\n    .flatMap((rec) => makeRecordIndex(rec))\n    .reduce(\n      (acc, cur) =>\n        mergeWith(acc, cur, (a, b) => {\n          if (Array.isArray(a)) return a.concat(b);\n        }),\n      {}\n    );\n}\n\nfunction makeRecordIndex<R extends Obj>(rec: R) {\n  return makeIndexPaths(rec).map((path) =>\n    buildNestedObject([rec.id], path.split(\"__.\"))\n  );\n}\n\nfunction makeIndexPaths({ id, ...obj }: Obj, acc?: string): string[] {\n  return Object.entries(obj).flatMap(([key, val]) =>\n    isObj(val)\n      ? makeIndexPaths(val, maybeJoin(key, acc))\n      : maybeJoin(`${key}__.${val}`, acc)\n  );\n}\n\n/****************************************************\n Index Query Handler\n****************************************************/\nfunction queryIndex(index: Index, query: Query): string[] {\n  return intersection(\n    ...makeQueryPaths(query).map((queryPath) =>\n      traverseIndex(\n        index,\n        Object.keys(queryPath)[0].split(\"__.\"),\n        Object.values(queryPath)[0]\n      )\n    )\n  );\n}\n\nfunction makeQueryPaths(query: Query, acc?: string): QueryPath[] {\n  return Object.keys(query).flatMap((key) =>\n    isObj(query[key])\n      ? makeQueryPaths(query[key], maybeJoin(key, acc))\n      : { [maybeJoin(key, acc)]: query[key] }\n  );\n}\n\nfunction traverseIndex(\n  index: Index,\n  path: string[],\n  value: boolean | number | string\n): string[] {\n  // empty path marks end of traversal\n  if (!path.length)\n    if (isRegStr(value)) {\n      const matchedKeys = matchKeysWRegExp(index, strToReg(value as string));\n      return matchedKeys.map((key) => index[key]).flat() as string[];\n    } else return index[`${value}`] as string[];\n\n  const [cur, ..._path] = path;\n\n  let _index: Index;\n  if (isRegStr(cur)) {\n    const matchedKeys = matchKeysWRegExp(index, strToReg(cur));\n    if (!matchedKeys.length) return [];\n\n    _index = matchedKeys.reduce(\n      (acc: Index, key) => ({ ...acc, ...((index[key] as Index) || {}) }),\n      {}\n    );\n  } else _index = index[cur] as Index;\n\n  if (!_index) return [];\n\n  return traverseIndex(_index, _path, value);\n}\n\n/****************************************************\n Types\n****************************************************/\ninterface Index {\n  [key: string]: Index | string[];\n}\n\ntype Obj = { id: string; [key: string]: any };\nexport type Query = { [key: string]: any };\ntype QueryPath = { [key: string]: boolean | number | string };\ntype QueryOptions = { conditions?: \"all\" | \"any\" | \"diff\" | \"none\" };\ntype QueryOpts = ReturnType<typeof makeOptions>;\n\nfunction makeOptions(options?: QueryOptions) {\n  return { conditions: options?.conditions };\n}\n\n/****************************************************\n Utilities\n****************************************************/\nfunction buildNestedObject(value: any, path: string[]) {\n  return path.reduceRight(\n    (acc, cur, index) =>\n      path.length - 1 <= index ? { [cur]: value } : { [cur]: acc },\n    {}\n  );\n}\n\nfunction isRegStr(it: any) {\n  try {\n    if (typeof it === \"string\") return !!strToReg(it as string);\n    return false;\n  } catch {\n    return false;\n  }\n}\n\nfunction maybeJoin(\n  a: boolean | number | string,\n  b: typeof ignore | boolean | number | string = ignore\n) {\n  return b === ignore ? `${a}` : `${b}__.${a}`;\n}\n\nfunction matchKeysWRegExp(obj: Index, re: RegExp): string[] {\n  return Object.keys(obj).filter((key) => re.test(key));\n}\n\nfunction strToReg(str: string) {\n  const pattern = str.slice(1, str.lastIndexOf(\"/\"));\n  const opts = str.slice(str.lastIndexOf(\"/\") + 1);\n  return new RegExp(pattern, opts);\n}\n"],"names":["ignore","Symbol","indexMap","WeakMap","search","entities","query","opts","Object","keys","index","get","set","root","values","flatMap","rec","makeIndexPaths","acc","obj","entries","key","val","isObj","maybeJoin","map","path","value","reduceRight","cur","length","[object Object]","buildNestedObject","id","split","makeRecordIndex","reduce","mergeWith","a","b","Array","isArray","concat","idSets","intersection","makeQueryPaths","queryPath","traverseIndex","isRegStr","matchKeysWRegExp","strToReg","flat","_path","_index","matchedKeys","queryIndex","conditions","Set","difference","slice","makeOptions","options","it","re","filter","test","str","pattern","lastIndexOf","RegExp"],"mappings":"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"}