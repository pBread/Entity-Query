{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import difference from \"lodash.difference\";\nimport intersection from \"lodash.intersection\";\nimport isObj from \"lodash.isplainobject\";\nimport mergeWith from \"lodash.mergewith\";\n\n/****************************************************\n Constants\n****************************************************/\nconst ignore = Symbol(); // allows undefined query values to be used\nconst indexMap = new WeakMap();\n\n/****************************************************\n Main\n****************************************************/\nexport function EntityQuery<T extends { [key: string]: R }, R extends Obj>(\n  entities: T // normalized entities\n) {\n  return {\n    filter(query?: Query, options?: QueryOptions): R[] {\n      return search(entities, query, makeOptions(options)).map(\n        (id) => entities[id]\n      );\n    },\n\n    search(query?: Query, options?: QueryOptions): string[] {\n      return search(entities, query, makeOptions(options));\n    },\n  };\n}\n\nfunction search<T extends { [key: string]: R }, R extends Obj>(\n  entities: T,\n  query: Query | Query[] | typeof ignore = ignore,\n  opts: QueryOpts\n): string[] {\n  if (query === ignore) return Object.keys(entities);\n\n  const index =\n    (indexMap.get(entities) as Index) ||\n    (indexMap.set(entities, makeIndex(entities)).get(entities) as Index);\n\n  const idSets = (Array.isArray(query) ? query : [query]).map((query) =>\n    queryIndex(index, query)\n  );\n\n  switch (opts.conditions) {\n    case \"all\":\n      return intersection(...idSets);\n\n    case \"any\":\n      return [...new Set(...idSets)];\n\n    case \"diff\":\n      return idSets.length >= 2\n        ? difference(idSets[0], ...idSets.slice(1))\n        : [];\n\n    case \"none\":\n      return difference(Object.keys(entities), ...idSets);\n\n    default:\n      return intersection(...idSets);\n  }\n}\n\n/****************************************************\n Index Builder\n****************************************************/\nfunction makeIndex<T extends { [key: string]: R }, R extends Obj>(\n  root: T\n): Index {\n  return Object.values(root)\n    .flatMap((rec) => makeRecordIndex(rec))\n    .reduce(\n      (acc, cur) =>\n        mergeWith(acc, cur, (a, b) => {\n          if (Array.isArray(a)) return a.concat(b);\n        }),\n      {}\n    );\n}\n\nfunction makeRecordIndex<R extends Obj>(rec: R) {\n  return makeIndexPaths(rec).map((path) =>\n    buildNestedObject([rec.id], path.split(\"__.\"))\n  );\n}\n\nfunction makeIndexPaths({ id, ...obj }: Obj, acc?: string): string[] {\n  return Object.entries(obj).flatMap(([key, val]) =>\n    isObj(val)\n      ? makeIndexPaths(val, maybeJoin(key, acc))\n      : maybeJoin(`${key}__.${val}`, acc)\n  );\n}\n\n/****************************************************\n Index Query Handler\n****************************************************/\nfunction queryIndex(index: Index, query: Query): string[] {\n  return intersection(\n    ...makeQueryPaths(query).map((queryPath) =>\n      traverseIndex(\n        index,\n        Object.keys(queryPath)[0].split(\"__.\"),\n        Object.values(queryPath)[0]\n      )\n    )\n  );\n}\n\nfunction makeQueryPaths(query: Query, acc?: string): QueryPath[] {\n  return Object.keys(query).flatMap((key) =>\n    isObj(query[key])\n      ? makeQueryPaths(query[key], maybeJoin(key, acc))\n      : { [maybeJoin(key, acc)]: query[key] }\n  );\n}\n\nfunction traverseIndex(\n  index: Index,\n  path: string[],\n  value: boolean | number | string\n): string[] {\n  // empty path marks end of traversal\n  if (!path.length)\n    if (isRegStr(value)) {\n      const matchedKeys = matchKeysWRegExp(index, strToReg(value as string));\n      return matchedKeys.map((key) => index[key]).flat() as string[];\n    } else return index[`${value}`] as string[];\n\n  const [cur, ..._path] = path;\n\n  let _index: Index;\n  if (isRegStr(cur)) {\n    const matchedKeys = matchKeysWRegExp(index, strToReg(cur));\n    if (!matchedKeys.length) return [];\n\n    _index = matchedKeys.reduce(\n      (acc: Index, key) => ({ ...acc, ...((index[key] as Index) || {}) }),\n      {}\n    );\n  } else _index = index[cur] as Index;\n\n  if (!_index) return [];\n\n  return traverseIndex(_index, _path, value);\n}\n\n/****************************************************\n Types\n****************************************************/\ninterface Index {\n  [key: string]: Index | string[];\n}\n\ntype Obj = { id: string; [key: string]: any };\nexport type Query = { [key: string]: any };\ntype QueryPath = { [key: string]: boolean | number | string };\ntype QueryOptions = { conditions?: \"all\" | \"any\" | \"diff\" | \"none\" };\ntype QueryOpts = ReturnType<typeof makeOptions>;\n\nfunction makeOptions(options?: QueryOptions) {\n  return { conditions: options?.conditions };\n}\n\n/****************************************************\n Utilities\n****************************************************/\nfunction buildNestedObject(value: any, path: string[]) {\n  return path.reduceRight(\n    (acc, cur, index) =>\n      path.length - 1 <= index ? { [cur]: value } : { [cur]: acc },\n    {}\n  );\n}\n\nfunction isRegStr(it: any) {\n  try {\n    if (typeof it === \"string\") return !!strToReg(it as string);\n    return false;\n  } catch {\n    return false;\n  }\n}\n\nfunction maybeJoin(\n  a: boolean | number | string,\n  b: typeof ignore | boolean | number | string = ignore\n) {\n  return b === ignore ? `${a}` : `${b}__.${a}`;\n}\n\nfunction matchKeysWRegExp(obj: Index, re: RegExp): string[] {\n  return Object.keys(obj).filter((key) => re.test(key));\n}\n\nfunction strToReg(str: string) {\n  const pattern = str.slice(1, str.lastIndexOf(\"/\"));\n  const opts = str.slice(str.lastIndexOf(\"/\") + 1);\n  return new RegExp(pattern, opts);\n}\n"],"names":["ignore","Symbol","indexMap","WeakMap","EntityQuery","entities","filter","query","options","search","makeOptions","map","id","opts","Object","keys","index","get","set","root","values","flatMap","rec","makeIndexPaths","acc","obj","entries","key","val","isObj","maybeJoin","path","value","reduceRight","cur","length","[object Object]","buildNestedObject","split","makeRecordIndex","reduce","mergeWith","a","b","Array","isArray","concat","idSets","intersection","makeQueryPaths","queryPath","traverseIndex","isRegStr","matchKeysWRegExp","strToReg","flat","_path","_index","matchedKeys","queryIndex","conditions","Set","difference","slice","it","re","test","str","pattern","lastIndexOf","RegExp"],"mappings":"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"}