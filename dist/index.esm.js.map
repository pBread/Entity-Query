{"version":3,"file":"index.esm.js","sources":["../src/index.ts"],"sourcesContent":["import difference from \"lodash.difference\";\nimport intersection from \"lodash.intersection\";\nimport isObj from \"lodash.isplainobject\";\nimport mergeWith from \"lodash.mergewith\";\n\n/****************************************************\n Constants\n****************************************************/\nconst ignore = Symbol(); // allows undefined query values to be used\nconst indexMap = new WeakMap();\n\n/****************************************************\n Main\n****************************************************/\nexport function EntityQuery<T extends { [key: string]: R }, R extends Obj>(\n  entities: T // normalized entities\n) {\n  return {\n    filter(query?: Query, options?: QueryOptions): R[] {\n      return search(entities, query, makeOptions(options)).map(\n        (id) => entities[id]\n      );\n    },\n\n    search(query?: Query, options?: QueryOptions): string[] {\n      return search(entities, query, makeOptions(options));\n    },\n  };\n}\n\nexport default EntityQuery\n\nfunction search<T extends { [key: string]: R }, R extends Obj>(\n  entities: T,\n  query: Query | Query[] | typeof ignore = ignore,\n  opts: QueryOpts\n): string[] {\n  if (query === ignore) return Object.keys(entities);\n\n  const index =\n    (indexMap.get(entities) as Index) ||\n    (indexMap.set(entities, makeIndex(entities)).get(entities) as Index);\n\n  const idSets = (Array.isArray(query) ? query : [query]).map((query) =>\n    queryIndex(index, query)\n  );\n\n  switch (opts.conditions) {\n    case \"all\":\n      return intersection(...idSets);\n\n    case \"any\":\n      return [...new Set(...idSets)];\n\n    case \"diff\":\n      return idSets.length >= 2\n        ? difference(idSets[0], ...idSets.slice(1))\n        : [];\n\n    case \"none\":\n      return difference(Object.keys(entities), ...idSets);\n\n    default:\n      return intersection(...idSets);\n  }\n}\n\n/****************************************************\n Index Builder\n****************************************************/\nfunction makeIndex<T extends { [key: string]: R }, R extends Obj>(\n  root: T\n): Index {\n  return Object.values(root)\n    .flatMap((rec) => makeRecordIndex(rec))\n    .reduce(\n      (acc, cur) =>\n        mergeWith(acc, cur, (a, b) => {\n          if (Array.isArray(a)) return a.concat(b);\n        }),\n      {}\n    );\n}\n\nfunction makeRecordIndex<R extends Obj>(rec: R) {\n  return makeIndexPaths(rec).map((path) =>\n    buildNestedObject([rec.id], path.split(\"__.\"))\n  );\n}\n\nfunction makeIndexPaths({ id, ...obj }: Obj, acc?: string): string[] {\n  return Object.entries(obj).flatMap(([key, val]) =>\n    isObj(val)\n      ? makeIndexPaths(val, maybeJoin(key, acc))\n      : maybeJoin(`${key}__.${val}`, acc)\n  );\n}\n\n/****************************************************\n Index Query Handler\n****************************************************/\nfunction queryIndex(index: Index, query: Query): string[] {\n  return intersection(\n    ...makeQueryPaths(query).map((queryPath) =>\n      traverseIndex(\n        index,\n        Object.keys(queryPath)[0].split(\"__.\"),\n        Object.values(queryPath)[0]\n      )\n    )\n  );\n}\n\nfunction makeQueryPaths(query: Query, acc?: string): QueryPath[] {\n  return Object.keys(query).flatMap((key) =>\n    isObj(query[key])\n      ? makeQueryPaths(query[key], maybeJoin(key, acc))\n      : { [maybeJoin(key, acc)]: query[key] }\n  );\n}\n\nfunction traverseIndex(\n  index: Index,\n  path: string[],\n  value: boolean | number | string\n): string[] {\n  // empty path marks end of traversal\n  if (!path.length)\n    if (isRegStr(value)) {\n      const matchedKeys = matchKeysWRegExp(index, strToReg(value as string));\n      return matchedKeys.map((key) => index[key]).flat() as string[];\n    } else return index[`${value}`] as string[];\n\n  const [cur, ..._path] = path;\n\n  let _index: Index;\n  if (isRegStr(cur)) {\n    const matchedKeys = matchKeysWRegExp(index, strToReg(cur));\n    if (!matchedKeys.length) return [];\n\n    _index = matchedKeys.reduce(\n      (acc: Index, key) => ({ ...acc, ...((index[key] as Index) || {}) }),\n      {}\n    );\n  } else _index = index[cur] as Index;\n\n  if (!_index) return [];\n\n  return traverseIndex(_index, _path, value);\n}\n\n/****************************************************\n Types\n****************************************************/\ninterface Index {\n  [key: string]: Index | string[];\n}\n\ntype Obj = { id: string; [key: string]: any };\nexport type Query = { [key: string]: any };\ntype QueryPath = { [key: string]: boolean | number | string };\ntype QueryOptions = { conditions?: \"all\" | \"any\" | \"diff\" | \"none\" };\ntype QueryOpts = ReturnType<typeof makeOptions>;\n\nfunction makeOptions(options?: QueryOptions) {\n  return { conditions: options?.conditions };\n}\n\n/****************************************************\n Utilities\n****************************************************/\nfunction buildNestedObject(value: any, path: string[]) {\n  return path.reduceRight(\n    (acc, cur, index) =>\n      path.length - 1 <= index ? { [cur]: value } : { [cur]: acc },\n    {}\n  );\n}\n\nfunction isRegStr(it: any) {\n  try {\n    if (typeof it === \"string\") return !!strToReg(it as string);\n    return false;\n  } catch {\n    return false;\n  }\n}\n\nfunction maybeJoin(\n  a: boolean | number | string,\n  b: typeof ignore | boolean | number | string = ignore\n) {\n  return b === ignore ? `${a}` : `${b}__.${a}`;\n}\n\nfunction matchKeysWRegExp(obj: Index, re: RegExp): string[] {\n  return Object.keys(obj).filter((key) => re.test(key));\n}\n\nfunction strToReg(str: string) {\n  const pattern = str.slice(1, str.lastIndexOf(\"/\"));\n  const opts = str.slice(str.lastIndexOf(\"/\") + 1);\n  return new RegExp(pattern, opts);\n}\n"],"names":["ignore","Symbol","indexMap","WeakMap","EntityQuery","entities","filter","query","options","search","makeOptions","map","id","opts","Object","keys","root","index","get","set","values","flatMap","rec","makeIndexPaths","acc","obj","entries","key","val","isObj","maybeJoin","path","value","reduceRight","cur","length","buildNestedObject","split","makeRecordIndex","reduce","mergeWith","a","b","Array","isArray","concat","idSets","intersection","makeQueryPaths","queryPath","traverseIndex","isRegStr","matchKeysWRegExp","strToReg","flat","_index","_path","matchedKeys","queryIndex","conditions","Set","difference","slice","it","re","test","str","pattern","lastIndexOf","RegExp"],"mappings":"o2BAQA,IAAMA,EAASC,SACTC,EAAW,IAAIC,iBAKLC,EACdC,GAEA,MAAO,CACLC,gBAAOC,EAAeC,GACpB,OAAOC,EAAOJ,EAAUE,EAAOG,EAAYF,IAAUG,IACnD,SAACC,UAAOP,EAASO,MAIrBH,gBAAOF,EAAeC,GACpB,OAAOC,EAAOJ,EAAUE,EAAOG,EAAYF,MAOjD,SAASC,EACPJ,EACAE,EACAM,GAEA,YAHAN,IAAAA,EAAyCP,GAGrCO,IAAUP,EAAQ,OAAOc,OAAOC,KAAKV,GAEzC,IAgCAW,EAhCMC,EACHf,EAASgB,IAAIb,IACbH,EAASiB,IAAId,GA8BhBW,EA9BoCX,EAgC7BS,OAAOM,OAAOJ,GAClBK,QAAQ,SAACC,UAUd,SAAwCA,GACtC,OAKF,SAASC,IAAoCC,GAAnBZ,IAAOa,+IAC/B,OAAOX,OAAOY,QAAQD,GAAKJ,QAAQ,gBAAEM,OAAKC,cACxCC,EAAMD,GACFL,EAAeK,EAAKE,EAAUH,EAAKH,IACnCM,EAAaH,QAASC,EAAOJ,KAT5BD,CAAeD,GAAKX,IAAI,SAACoB,UAsFlC,SAA2BC,EAAYD,GACrC,OAAOA,EAAKE,YACV,SAACT,EAAKU,EAAKjB,kBACTc,EAAKI,OAAS,GAAKlB,UAAWiB,GAAMF,aAAaE,GAAMV,MACzD,IAzFAY,CAAkB,CAACd,EAAIV,IAAKmB,EAAKM,MAAM,UAZrBC,CAAgBhB,KACjCiB,OACC,SAACf,EAAKU,UACJM,EAAUhB,EAAKU,EAAK,SAACO,EAAGC,GACtB,GAAIC,MAAMC,QAAQH,GAAI,OAAOA,EAAEI,OAAOH,MAE1C,MAvC2CxB,IAAIb,GAE7CyC,GAAUH,MAAMC,QAAQrC,GAASA,EAAQ,CAACA,IAAQI,IAAI,SAACJ,UA0D/D,SAAoBU,EAAcV,GAChC,OAAOwC,eAWT,SAASC,EAAezC,EAAciB,GACpC,OAAOV,OAAOC,KAAKR,GAAOc,QAAQ,SAACM,gBACjCE,EAAMtB,EAAMoB,IACRqB,EAAezC,EAAMoB,GAAMG,EAAUH,EAAKH,YACvCM,EAAUH,EAAKH,IAAOjB,EAAMoB,QAdhCqB,CAAezC,GAAOI,IAAI,SAACsC,UAkBlC,SAASC,EACPjC,EACAc,EACAC,GAGA,IAAKD,EAAKI,OACR,OAAIgB,EAASnB,GACSoB,EAAiBnC,EAAOoC,EAASrB,IAClCrB,IAAI,SAACgB,UAAQV,EAAMU,KAAM2B,OAChCrC,KAASe,OAIrBuB,EAFGrB,EAAiBH,KAATyB,EAASzB,WAGxB,GAAIoB,EAASjB,GAAM,CACjB,IAAMuB,EAAcL,EAAiBnC,EAAOoC,EAASnB,IACrD,IAAKuB,EAAYtB,OAAQ,MAAO,GAEhCoB,EAASE,EAAYlB,OACnB,SAACf,EAAYG,eAAcH,EAAUP,EAAMU,IAAkB,KAC7D,SAEG4B,EAAStC,EAAMiB,GAEtB,OAAKqB,EAEEL,EAAcK,EAAQC,EAAOxB,GAFhB,GA1ChBkB,CACEjC,EACAH,OAAOC,KAAKkC,GAAW,GAAGZ,MAAM,OAChCvB,OAAOM,OAAO6B,GAAW,OA/D7BS,CAAWzC,EAAOV,KAGpB,OAAQM,EAAK8C,YACX,IAAK,MACH,OAAOZ,eAAgBD,GAEzB,IAAK,MACH,kBAAec,IAAOd,IAExB,IAAK,OACH,OAAOA,EAAOX,QAAU,EACpB0B,gBAAWf,EAAO,WAAOA,EAAOgB,MAAM,KACtC,GAEN,IAAK,OACH,OAAOD,gBAAW/C,OAAOC,KAAKV,WAAcyC,IAE9C,QACE,OAAOC,eAAgBD,IAqG7B,SAASpC,EAAYF,GACnB,MAAO,CAAEmD,iBAAYnD,SAAAA,EAASmD,YAchC,SAASR,EAASY,GAChB,IACE,MAAkB,iBAAPA,KAA0BV,EAASU,GAE9C,SACA,UAIJ,SAASjC,EACPW,EACAC,GAEA,gBAFAA,IAAAA,EAA+C1C,GAExC0C,IAAM1C,KAAYyC,EAASC,QAAOD,EAG3C,SAASW,EAAiB3B,EAAYuC,GACpC,OAAOlD,OAAOC,KAAKU,GAAKnB,OAAO,SAACqB,UAAQqC,EAAGC,KAAKtC,KAGlD,SAAS0B,EAASa,GAChB,IAAMC,EAAUD,EAAIJ,MAAM,EAAGI,EAAIE,YAAY,MACvCvD,EAAOqD,EAAIJ,MAAMI,EAAIE,YAAY,KAAO,GAC9C,WAAWC,OAAOF,EAAStD"}