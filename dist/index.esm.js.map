{"version":3,"file":"index.esm.js","sources":["../src/index.ts"],"sourcesContent":["import difference from \"lodash.difference\";\nimport intersection from \"lodash.intersection\";\nimport isObj from \"lodash.isplainobject\";\nimport mergeWith from \"lodash.mergewith\";\n\n/****************************************************\n Constants\n****************************************************/\nconst ignore = Symbol(); // allows undefined query values to be used\nconst indexMap = new WeakMap();\n\n/****************************************************\n Main\n****************************************************/\nfunction EntityQuery<T extends { [key: string]: R }, R extends Obj>(\n  entities: T // normalized entities\n) {\n  return {\n    filter(query?: Query, options?: QueryOptions): R[] {\n      return search(entities, query, makeOptions(options)).map(\n        (id) => entities[id]\n      );\n    },\n\n    search(query?: Query, options?: QueryOptions): string[] {\n      return search(entities, query, makeOptions(options));\n    },\n  };\n}\n\nexport default EntityQuery;\n\nfunction search<T extends { [key: string]: R }, R extends Obj>(\n  entities: T,\n  query: Query | Query[] | typeof ignore = ignore,\n  opts: QueryOpts\n): string[] {\n  if (query === ignore) return Object.keys(entities);\n\n  const index =\n    (indexMap.get(entities) as Index) ||\n    (indexMap.set(entities, makeIndex(entities)).get(entities) as Index);\n\n  const idSets = (Array.isArray(query) ? query : [query]).map((query) =>\n    queryIndex(index, query)\n  );\n\n  switch (opts.conditions) {\n    case \"all\":\n      return intersection(...idSets);\n\n    case \"any\":\n      return [...new Set(...idSets)];\n\n    case \"diff\":\n      return idSets.length >= 2\n        ? difference(idSets[0], ...idSets.slice(1))\n        : [];\n\n    case \"none\":\n      return difference(Object.keys(entities), ...idSets);\n\n    default:\n      return intersection(...idSets);\n  }\n}\n\n/****************************************************\n Index Builder\n****************************************************/\nfunction makeIndex<T extends { [key: string]: R }, R extends Obj>(\n  root: T\n): Index {\n  return Object.values(root)\n    .flatMap((rec) => makeRecordIndex(rec))\n    .reduce(\n      (acc, cur) =>\n        mergeWith(acc, cur, (a, b) => {\n          if (Array.isArray(a)) return a.concat(b);\n        }),\n      {}\n    );\n}\n\nfunction makeRecordIndex<R extends Obj>(rec: R) {\n  return makeIndexPaths(rec).map((path) =>\n    buildNestedObject([rec.id], path.split(\"__.\"))\n  );\n}\n\nfunction makeIndexPaths({ id, ...obj }: Obj, acc?: string): string[] {\n  return Object.entries(obj).flatMap(([key, val]) =>\n    isObj(val)\n      ? makeIndexPaths(val, maybeJoin(key, acc))\n      : maybeJoin(`${key}__.${val}`, acc)\n  );\n}\n\n/****************************************************\n Index Query Handler\n****************************************************/\nfunction queryIndex(index: Index, query: Query): string[] {\n  return intersection(\n    ...makeQueryPaths(query).map((queryPath) =>\n      traverseIndex(\n        index,\n        Object.keys(queryPath)[0].split(\"__.\"),\n        Object.values(queryPath)[0]\n      )\n    )\n  );\n}\n\nfunction makeQueryPaths(query: Query, acc?: string): QueryPath[] {\n  return Object.keys(query).flatMap((key) =>\n    isObj(query[key])\n      ? makeQueryPaths(query[key], maybeJoin(key, acc))\n      : { [maybeJoin(key, acc)]: query[key] }\n  );\n}\n\nfunction traverseIndex(\n  index: Index,\n  path: string[],\n  value: boolean | number | string\n): string[] {\n  // empty path marks end of traversal\n  if (!path.length)\n    if (isRegStr(value)) {\n      const matchedKeys = matchKeysWRegExp(index, strToReg(value as string));\n      return matchedKeys.map((key) => index[key]).flat() as string[];\n    } else return index[`${value}`] as string[];\n\n  const [cur, ..._path] = path;\n\n  let _index: Index;\n  if (isRegStr(cur)) {\n    const matchedKeys = matchKeysWRegExp(index, strToReg(cur));\n    if (!matchedKeys.length) return [];\n\n    _index = matchedKeys.reduce(\n      (acc: Index, key) => ({ ...acc, ...((index[key] as Index) || {}) }),\n      {}\n    );\n  } else _index = index[cur] as Index;\n\n  if (!_index) return [];\n\n  return traverseIndex(_index, _path, value);\n}\n\n/****************************************************\n Types\n****************************************************/\ninterface Index {\n  [key: string]: Index | string[];\n}\n\ntype Obj = { id: string; [key: string]: any };\nexport type Query = { [key: string]: any };\ntype QueryPath = { [key: string]: boolean | number | string };\ntype QueryOptions = { conditions?: \"all\" | \"any\" | \"diff\" | \"none\" };\ntype QueryOpts = ReturnType<typeof makeOptions>;\n\nfunction makeOptions(options?: QueryOptions) {\n  return { conditions: options?.conditions };\n}\n\n/****************************************************\n Utilities\n****************************************************/\nfunction buildNestedObject(value: any, path: string[]) {\n  return path.reduceRight(\n    (acc, cur, index) =>\n      path.length - 1 <= index ? { [cur]: value } : { [cur]: acc },\n    {}\n  );\n}\n\nfunction isRegStr(it: any) {\n  try {\n    if (typeof it === \"string\") return !!strToReg(it as string);\n    return false;\n  } catch {\n    return false;\n  }\n}\n\nfunction maybeJoin(\n  a: boolean | number | string,\n  b: typeof ignore | boolean | number | string = ignore\n) {\n  return b === ignore ? `${a}` : `${b}__.${a}`;\n}\n\nfunction matchKeysWRegExp(obj: Index, re: RegExp): string[] {\n  return Object.keys(obj).filter((key) => re.test(key));\n}\n\nfunction strToReg(str: string) {\n  const pattern = str.slice(1, str.lastIndexOf(\"/\"));\n  const opts = str.slice(str.lastIndexOf(\"/\") + 1);\n  return new RegExp(pattern, opts);\n}\n"],"names":["ignore","Symbol","indexMap","WeakMap","search","entities","query","opts","Object","keys","root","index","get","set","values","flatMap","rec","makeIndexPaths","acc","id","obj","entries","key","val","isObj","maybeJoin","map","path","value","reduceRight","cur","length","buildNestedObject","split","makeRecordIndex","reduce","mergeWith","a","b","Array","isArray","concat","idSets","intersection","makeQueryPaths","queryPath","traverseIndex","isRegStr","matchKeysWRegExp","strToReg","flat","_index","_path","matchedKeys","queryIndex","conditions","Set","difference","slice","makeOptions","options","it","re","filter","test","str","pattern","lastIndexOf","RegExp"],"mappings":"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"}