{"version":3,"file":"index.esm.js","sources":["../src/index.ts"],"sourcesContent":["import difference from \"lodash.difference\";\nimport intersection from \"lodash.intersection\";\nimport isObj from \"lodash.isplainobject\";\nimport mergeWith from \"lodash.mergewith\";\n\n/****************************************************\n Constants\n****************************************************/\nconst ignore = Symbol(); // allows undefined query values to be used\nconst indexMap = new WeakMap();\n\n/****************************************************\n Main\n****************************************************/\nexport default function EntityQuery<\n  T extends { [key: string]: R },\n  R extends Obj\n>(\n  entities: T // normalized entities\n) {\n  return {\n    filter(query?: Query, options?: QueryOptions): R[] {\n      return search(entities, query, makeOptions(options)).map(\n        (id) => entities[id]\n      );\n    },\n\n    search(query?: Query, options?: QueryOptions): string[] {\n      return search(entities, query, makeOptions(options));\n    },\n  };\n}\n\nfunction search<T extends { [key: string]: R }, R extends Obj>(\n  entities: T,\n  query: Query | Query[] | typeof ignore = ignore,\n  opts: QueryOpts\n): string[] {\n  if (query === ignore) return Object.keys(entities);\n\n  const index =\n    (indexMap.get(entities) as Index) ||\n    (indexMap.set(entities, makeIndex(entities)).get(entities) as Index);\n\n  const idSets = (Array.isArray(query) ? query : [query]).map((query) =>\n    queryIndex(index, query)\n  );\n\n  switch (opts.conditions) {\n    case \"all\":\n      return intersection(...idSets);\n\n    case \"any\":\n      return [...new Set(...idSets)];\n\n    case \"diff\":\n      return idSets.length >= 2\n        ? difference(idSets[0], ...idSets.slice(1))\n        : [];\n\n    case \"none\":\n      return difference(Object.keys(entities), ...idSets);\n\n    default:\n      throw Error(`Invalid Query Conditon: ${opts.conditions}`);\n  }\n}\n\n/****************************************************\n Index Builder\n****************************************************/\nfunction makeIndex<T extends { [key: string]: R }, R extends Obj>(\n  root: T\n): Index {\n  return Object.values(root)\n    .flatMap((rec) => makeRecordIndex(rec))\n    .reduce(\n      (acc, cur) =>\n        mergeWith(acc, cur, (a, b) => {\n          if (Array.isArray(a)) return a.concat(b);\n        }),\n      {}\n    );\n}\n\nfunction makeRecordIndex<R extends Obj>(rec: R) {\n  return makeIndexPaths(rec).map((path) =>\n    buildNestedObject([rec.id], path.split(\"__.\"))\n  );\n}\n\nfunction makeIndexPaths({ id, ...obj }: Obj, acc?: string): string[] {\n  return Object.entries(obj).flatMap(([key, val]) =>\n    isObj(val)\n      ? makeIndexPaths(val, maybeJoin(key, acc))\n      : maybeJoin(`${key}__.${val}`, acc)\n  );\n}\n\n/****************************************************\n Index Query Handler\n****************************************************/\nfunction queryIndex(index: Index, query: Query): string[] {\n  return intersection(\n    ...makeQueryPaths(query).map((queryPath) =>\n      traverseIndex(\n        index,\n        Object.keys(queryPath)[0].split(\"__.\"),\n        Object.values(queryPath)[0]\n      )\n    )\n  );\n}\n\nfunction makeQueryPaths(query: Query, acc?: string): QueryPath[] {\n  return Object.keys(query).flatMap((key) =>\n    isObj(query[key])\n      ? makeQueryPaths(query[key], maybeJoin(key, acc))\n      : { [maybeJoin(key, acc)]: query[key] }\n  );\n}\n\nfunction traverseIndex(\n  index: Index,\n  path: string[],\n  value: boolean | number | string\n): string[] {\n  // empty path marks end of traversal\n  if (!path.length)\n    if (isRegStr(value))\n      return matchKeysWRegExp(index, strToReg(value as string))\n        .map((key) => index[key])\n        .flat() as string[];\n    else return index[`${value}`] as string[];\n\n  const [cur, ...nextPath] = path;\n\n  const nextIndex = isRegStr(cur)\n    ? matchKeysWRegExp(index, strToReg(cur)).reduce(\n        (acc: Index, key) => ({\n          ...acc,\n          ...((index[key] as Index) || {}),\n        }),\n        {}\n      )\n    : (index[cur] as Index);\n\n  if (!nextIndex) return [];\n\n  return traverseIndex(nextIndex, nextPath, value);\n}\n\n/****************************************************\n Types\n****************************************************/\ninterface Index {\n  [key: string]: Index | string[];\n}\n\nexport type Query = { [key: string]: any };\nexport type QueryOptions = { conditions?: \"all\" | \"any\" | \"diff\" | \"none\" };\n\ntype Obj = { id: string; [key: string]: any };\ntype QueryOpts = ReturnType<typeof makeOptions>;\ntype QueryPath = { [key: string]: boolean | number | string };\n\nfunction makeOptions(options?: QueryOptions) {\n  return { conditions: options?.conditions };\n}\n\n/****************************************************\n Utilities\n****************************************************/\nfunction buildNestedObject(value: any, path: string[]) {\n  return path.reduceRight(\n    (acc, cur, index) =>\n      path.length - 1 <= index ? { [cur]: value } : { [cur]: acc },\n    {}\n  );\n}\n\nfunction isRegStr(it: any) {\n  try {\n    if (typeof it === \"string\") return !!strToReg(it as string);\n    return false;\n  } catch {\n    return false;\n  }\n}\n\nfunction maybeJoin(\n  a: boolean | number | string,\n  b: typeof ignore | boolean | number | string = ignore\n) {\n  return b === ignore ? `${a}` : `${b}__.${a}`;\n}\n\nfunction matchKeysWRegExp(obj: Index, re: RegExp): string[] {\n  return Object.keys(obj).filter((key) => re.test(key));\n}\n\nfunction strToReg(str: string) {\n  const pattern = str.slice(1, str.lastIndexOf(\"/\"));\n  const opts = str.slice(str.lastIndexOf(\"/\") + 1);\n  return new RegExp(pattern, opts);\n}\n"],"names":["ignore","Symbol","indexMap","WeakMap","search","entities","query","opts","Object","keys","root","index","get","set","values","flatMap","rec","makeIndexPaths","acc","id","obj","entries","key","val","isObj","maybeJoin","map","path","value","reduceRight","cur","length","buildNestedObject","split","makeRecordIndex","reduce","mergeWith","a","b","Array","isArray","concat","idSets","intersection","makeQueryPaths","queryPath","traverseIndex","isRegStr","matchKeysWRegExp","strToReg","flat","nextPath","nextIndex","queryIndex","conditions","Set","difference","slice","Error","makeOptions","options","it","re","filter","test","str","pattern","lastIndexOf","RegExp"],"mappings":"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"}